
破坏单例模式的方式：
	1、问题：通过反射破坏，通过强制访问，调用构造器创造类实例
	   解决：在私有构造器中进行判断
				if (INSTANCE != null) {
					throw new Exception("Not allowed!");
				}
			JDK中，对枚举类进行控制，天然的不被反射破坏；
	2、问题：用过序列化破坏，OBJECT类型的对象，在反序列化过程中，会new一个新对象
	   解决：在单例中重写readResolve方法，反序列化过程中，通过判断是否存在该方法，存在则会调用该方法，
			对已经new出来的对象进行覆盖；

单例模式写法的优缺点
	1、	饿汉式（在类初识化时直接创建一个实例）
		优点：线程安全，执行效率高
		缺点：如果该类并不使用，但依然会创建对象，浪费内存
	
	2、 懒汉式（在调用的时候，进行初始化）
		优点：只在需要时才初始化，不会过多浪费内存
		缺点：本身线程不安全，需要加锁控制
	
	3、 静态内部类懒汉式
	    优点：调用该内部类的静态方法时才初始化，线程安全
		      不被反射破坏，通过反射，是不能从外部类获取内部类的属性的

	4、 枚举单例（注册式）
		优点：线程安全，在jdk层面就控制避免被反射以及反序列化破坏
		缺点：可读性较低，不易明白
	
	5、 容器类单例（注册式）
		优点：统一容器来管理，把对象保存到map中，再根据唯一key进行获取，减低耦合
		缺点：线程不安全
	
	6、 ThreadLocal模式
		优点：线程间是线程安全
		缺点：但是每个线程会有自己的一份，多线程情况下会创建多个实例
	
	
	
	
	
		
